<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookmark Optimizer & Diff Tool</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; line-height: 1.6; }
        h1 { border-bottom: 2px solid #ddd; padding-bottom: 10px; font-size: 24px; }
        .container { background: #f9f9f9; padding: 20px; border-radius: 8px; border: 1px solid #eee; }
        .drop-zone { border: 2px dashed #ccc; padding: 40px; text-align: center; background: white; cursor: pointer; border-radius: 4px; transition: 0.2s; }
        .drop-zone:hover, .drop-zone.dragover { border-color: #007bff; background: #eef7ff; }
        input[type="file"] { display: none; }
        
        .btn-group { display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; }
        button { flex: 1; padding: 12px; font-size: 15px; border-radius: 4px; cursor: pointer; border: none; font-weight: bold; color: white; transition: 0.2s; }
        
        /* 青いボタン（統合） */
        .btn-primary { background: #007bff; }
        .btn-primary:hover:not(:disabled) { background: #0056b3; }
        
        /* 緑のボタン（差分） */
        .btn-success { background: #28a745; }
        .btn-success:hover:not(:disabled) { background: #218838; }

        button:disabled { background: #ccc; cursor: not-allowed; }

        #status { margin-top: 20px; white-space: pre-wrap; font-family: monospace; font-size: 0.9em; background: #333; color: #fff; padding: 10px; border-radius: 4px; display: none; }
        .stats { margin-top: 10px; font-weight: bold; color: #555; }
        .note { font-size: 0.85em; color: #666; margin-top: 5px; }
    </style>
</head>
<body>

    <h1>Bookmark Optimizer & Diff Tool</h1>
    <p>複数のブックマークHTMLを処理します。重複削除・軽量化・ドメイン整理に加え、ファイル間の差分抽出も可能です。</p>

    <div class="container">
        <div class="drop-zone" id="dropZone">
            <p>ここにブックマークHTMLファイルをドラッグ＆ドロップ<br>（2つ以上のファイルを推奨）</p>
            <input type="file" id="fileInput" multiple accept=".html,.htm">
        </div>
        
        <div class="stats" id="stats"></div>

        <div class="btn-group">
            <button id="downloadMergeBtn" class="btn-primary" disabled>
                すべて統合してダウンロード<br>
                <span style="font-size:0.8em; font-weight:normal;">(重複は1つにまとめる)</span>
            </button>
            <button id="downloadDiffBtn" class="btn-success" disabled>
                差分(重複なし)のみダウンロード<br>
                <span style="font-size:0.8em; font-weight:normal;">(重なっているものは全て捨てる)</span>
            </button>
        </div>
    </div>

    <div id="status"></div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const downloadMergeBtn = document.getElementById('downloadMergeBtn');
        const downloadDiffBtn = document.getElementById('downloadDiffBtn');
        const statusDiv = document.getElementById('status');
        const statsDiv = document.getElementById('stats');

        // URLをキーにしてデータを保持。どのファイルに含まれていたかのSetを持つ
        // Map<URL, { title, addDate, hostname, fileIndices: Set<number> }>
        let urlMap = new Map();
        let fileCount = 0;

        // Event Listeners
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        async function handleFiles(files) {
            if (files.length === 0) return;
            
            reset();
            fileCount = files.length;
            log(`ファイルを ${fileCount} 件 読み込み中...`);

            const promises = Array.from(files).map(readFile);
            const contents = await Promise.all(promises);

            processContents(contents);
        }

        function readFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsText(file);
            });
        }

        function reset() {
            urlMap.clear();
            statusDiv.style.display = 'block';
            statusDiv.textContent = '';
            statsDiv.textContent = '';
            downloadMergeBtn.disabled = true;
            downloadDiffBtn.disabled = true;
        }

        function log(msg) {
            statusDiv.textContent += msg + "\n";
        }

        function processContents(htmlContents) {
            const parser = new DOMParser();
            let totalLinksFound = 0;

            htmlContents.forEach((html, fileIndex) => {
                const doc = parser.parseFromString(html, "text/html");
                const links = doc.querySelectorAll('a');
                
                log(`ファイル ${fileIndex + 1}: ${links.length} 個のリンクを検出`);
                totalLinksFound += links.length;

                links.forEach(a => {
                    const url = a.getAttribute('href');
                    const title = a.textContent;
                    // 日付がない場合は現在時刻
                    const addDate = a.getAttribute('add_date') || Math.floor(Date.now() / 1000);

                    if (!url || !url.startsWith('http')) return;

                    // URL解析
                    let hostname = 'Others';
                    try {
                        hostname = new URL(url).hostname;
                    } catch (e) {}

                    // マップに登録
                    if (!urlMap.has(url)) {
                        urlMap.set(url, {
                            title: title || url,
                            url: url,
                            addDate: addDate,
                            hostname: hostname,
                            fileIndices: new Set()
                        });
                    }
                    
                    // このURLがどのファイル(index)に存在したかを記録
                    urlMap.get(url).fileIndices.add(fileIndex);
                });
            });

            // 集計
            const allUniqueUrls = Array.from(urlMap.values());
            
            // 統合版（マージ）: 単純にマップにある数
            const mergedCount = allUniqueUrls.length;

            // 差分版（Diff）: 出現ファイル数が「1」のものだけ抽出
            // (つまり、複数のファイルでかぶっているものは除外)
            const diffItems = allUniqueUrls.filter(item => item.fileIndices.size === 1);
            const diffCount = diffItems.length;

            log(`--------------------------`);
            log(`解析完了:`);
            log(`- 総リンク数 (重複込): ${totalLinksFound}`);
            log(`- 統合後の数 (ユニーク): ${mergedCount}`);
            log(`- 差分のみの数 (非重複): ${diffCount}`);
            log(`  (複数のファイルに含まれていた ${mergedCount - diffCount} 件の共通リンクは差分版から除外されます)`);

            statsDiv.innerHTML = `
                検出完了: ユニークURL数 ${mergedCount}件<br>
                <span class="note">うち、他のファイルと被っていないURLは ${diffCount}件 です。</span>
            `;
            
            downloadMergeBtn.disabled = false;
            downloadDiffBtn.disabled = false;
        }

        // ダウンロードボタン（統合）
        downloadMergeBtn.addEventListener('click', () => {
            // 全データをドメインでソート
            const bookmarks = Array.from(urlMap.values())
                .sort((a, b) => a.hostname.localeCompare(b.hostname));
            
            downloadHTML(bookmarks, 'bookmarks_merged');
        });

        // ダウンロードボタン（差分）
        downloadDiffBtn.addEventListener('click', () => {
            // 出現ファイル数が1のものだけフィルタリングしてソート
            const bookmarks = Array.from(urlMap.values())
                .filter(item => item.fileIndices.size === 1)
                .sort((a, b) => a.hostname.localeCompare(b.hostname));

            downloadHTML(bookmarks, 'bookmarks_diff_unique');
        });

        function downloadHTML(bookmarks, filenamePrefix) {
            const outputHTML = generateNetscapeHTML(bookmarks);
            const blob = new Blob([outputHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${filenamePrefix}_${new Date().toISOString().slice(0,10)}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // サイトごとにフォルダ分けしたHTMLを生成
        function generateNetscapeHTML(bookmarks) {
            const grouped = {};
            bookmarks.forEach(b => {
                if (!grouped[b.hostname]) grouped[b.hostname] = [];
                grouped[b.hostname].push(b);
            });

            let html = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- Generated by Bookmark Optimizer -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
`;

            for (const [hostname, items] of Object.entries(grouped)) {
                html += `    <DT><H3 ADD_DATE="${Math.floor(Date.now() / 1000)}">${hostname}</H3>\n`;
                html += `    <DL><p>\n`;
                items.forEach(item => {
                    html += `        <DT><A HREF="${item.url}" ADD_DATE="${item.addDate}">${escapeHtml(item.title)}</A>\n`;
                });
                html += `    </DL><p>\n`;
            }

            html += `</DL><p>`;
            return html;
        }

        function escapeHtml(text) {
            if (!text) return "";
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>