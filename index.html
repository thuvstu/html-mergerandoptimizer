<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookmark Optimizer & Merger</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; line-height: 1.6; }
        h1 { border-bottom: 2px solid #ddd; padding-bottom: 10px; }
        .container { background: #f9f9f9; padding: 20px; border-radius: 8px; border: 1px solid #eee; }
        .drop-zone { border: 2px dashed #ccc; padding: 40px; text-align: center; background: white; cursor: pointer; border-radius: 4px; transition: 0.2s; }
        .drop-zone:hover, .drop-zone.dragover { border-color: #007bff; background: #eef7ff; }
        input[type="file"] { display: none; }
        button { background: #007bff; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 4px; cursor: pointer; margin-top: 20px; disabled: true; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        #status { margin-top: 20px; white-space: pre-wrap; font-family: monospace; font-size: 0.9em; background: #333; color: #fff; padding: 10px; border-radius: 4px; display: none; }
        .stats { margin-top: 10px; font-weight: bold; color: #555; }
    </style>
</head>
<body>

    <h1>Bookmark Merger & Optimizer</h1>
    <p>複数のブックマークHTMLを結合し、重複削除・軽量化・ドメイン別整理を行って書き出します。<br>※処理はすべてお使いのブラウザ内で行われます。データが外部に送信されることはありません。</p>

    <div class="container">
        <div class="drop-zone" id="dropZone">
            <p>ここにブックマークHTMLファイルをドラッグ＆ドロップ<br>またはクリックして選択（複数可）</p>
            <input type="file" id="fileInput" multiple accept=".html,.htm">
        </div>
        
        <div class="stats" id="stats"></div>
        <button id="downloadBtn" disabled>処理されたブックマークをダウンロード</button>
    </div>

    <div id="status"></div>

    <script>
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const downloadBtn = document.getElementById('downloadBtn');
        const statusDiv = document.getElementById('status');
        const statsDiv = document.getElementById('stats');

        let mergedBookmarks = []; // { title, url, addDate, hostname }

        // Event Listeners
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));

        async function handleFiles(files) {
            if (files.length === 0) return;
            
            reset();
            log(`ファイルを ${files.length} 件 読み込み中...`);

            const promises = Array.from(files).map(readFile);
            const contents = await Promise.all(promises);

            processContents(contents);
        }

        function readFile(file) {
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.readAsText(file);
            });
        }

        function reset() {
            mergedBookmarks = [];
            statusDiv.style.display = 'block';
            statusDiv.textContent = '';
            statsDiv.textContent = '';
            downloadBtn.disabled = true;
        }

        function log(msg) {
            statusDiv.textContent += msg + "\n";
        }

        function processContents(htmlContents) {
            const parser = new DOMParser();
            const urlSet = new Set();
            let totalLinksFound = 0;

            htmlContents.forEach((html, index) => {
                const doc = parser.parseFromString(html, "text/html");
                const links = doc.querySelectorAll('a');
                
                log(`ファイル ${index + 1}: ${links.length} 個のリンクを検出`);
                totalLinksFound += links.length;

                links.forEach(a => {
                    const url = a.getAttribute('href');
                    const title = a.textContent;
                    const addDate = a.getAttribute('add_date') || Math.floor(Date.now() / 1000);

                    // Validate URL
                    if (!url || !url.startsWith('http')) return;

                    // 重複チェック (重複削除)
                    if (urlSet.has(url)) return;

                    urlSet.add(url);

                    try {
                        const hostname = new URL(url).hostname;
                        mergedBookmarks.push({
                            title: title || url,
                            url: url,
                            addDate: addDate,
                            hostname: hostname
                        });
                    } catch (e) {
                        // URL解析エラーの場合は "Others" に分類
                        mergedBookmarks.push({
                            title: title || url,
                            url: url,
                            addDate: addDate,
                            hostname: 'Others'
                        });
                    }
                });
            });

            // ホスト名でソート（フォルダが見やすくなるように）
            mergedBookmarks.sort((a, b) => a.hostname.localeCompare(b.hostname));

            const uniqueCount = mergedBookmarks.length;
            const removedCount = totalLinksFound - uniqueCount;

            log(`--------------------------`);
            log(`処理完了:`);
            log(`- 総リンク数: ${totalLinksFound}`);
            log(`- 重複削除数: ${removedCount}`);
            log(`- 有効リンク数: ${uniqueCount}`);
            log(`- 軽量化: アイコンデータ(ICON)を除去しました`);
            log(`- 最適化: ドメインごとにフォルダ分けしました`);

            statsDiv.textContent = `統合完了: ${uniqueCount} ブックマーク (重複削除: ${removedCount})`;
            downloadBtn.disabled = false;
        }

        downloadBtn.addEventListener('click', () => {
            const outputHTML = generateNetscapeHTML(mergedBookmarks);
            const blob = new Blob([outputHTML], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bookmarks_optimized_${new Date().toISOString().slice(0,10)}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // サイトごとにフォルダ分けしたHTMLを生成
        function generateNetscapeHTML(bookmarks) {
            // ドメインごとにグループ化
            const grouped = {};
            bookmarks.forEach(b => {
                if (!grouped[b.hostname]) grouped[b.hostname] = [];
                grouped[b.hostname].push(b);
            });

            let html = `<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- This is an automatically generated file.
     It will be read and overwritten.
     DO NOT EDIT! -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
`;

            // グループごとにフォルダを作成
            for (const [hostname, items] of Object.entries(grouped)) {
                html += `    <DT><H3 ADD_DATE="${Math.floor(Date.now() / 1000)}">${hostname}</H3>\n`;
                html += `    <DL><p>\n`;
                
                items.forEach(item => {
                    // ICON属性を含めないことで軽量化
                    html += `        <DT><A HREF="${item.url}" ADD_DATE="${item.addDate}">${escapeHtml(item.title)}</A>\n`;
                });

                html += `    </DL><p>\n`;
            }

            html += `</DL><p>`;
            return html;
        }

        function escapeHtml(text) {
            if (!text) return "";
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }
    </script>
</body>
</html>